generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

enum ThoughtType {
  task
  idea
  note
  reminder
  journal
}

enum ThoughtStatus {
  active
  done
  snoozed
  archived
}

model User {
  id                 String         @id @default(uuid()) @db.Uuid
  email              String         @unique @db.VarChar(255)
  name               String?        @db.VarChar(255)
  passwordHash       String?        @map("password_hash") @db.VarChar(255)
  emailVerified      DateTime?      @map("email_verified") @db.Timestamptz()
  preferences        Json           @default("{}")
  createdAt          DateTime       @default(now()) @map("created_at") @db.Timestamptz()
  thoughts           Thought[]
  notifications      Notification[]
  conversations      Conversation[]
  pushSubscriptions  PushSubscription[]
  accounts           Account[]
  verificationTokens VerificationToken[]

  @@map("users")
}

model Conversation {
  id        String        @id @default(uuid()) @db.Uuid
  userId    String        @map("user_id") @db.Uuid
  title     String?
  createdAt DateTime      @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt DateTime      @default(now()) @updatedAt @map("updated_at") @db.Timestamptz()
  user      User          @relation(fields: [userId], references: [id])
  messages  ChatMessage[]

  @@index([userId, updatedAt])
  @@map("conversations")
}

model ChatMessage {
  id             String       @id @default(uuid()) @db.Uuid
  conversationId String       @map("conversation_id") @db.Uuid
  role           String       @db.VarChar(20)
  content        String
  sources        Json         @default("[]")
  createdAt      DateTime     @default(now()) @map("created_at") @db.Timestamptz()
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@map("chat_messages")
}

model Thought {
  id              String        @id @default(uuid()) @db.Uuid
  userId          String        @map("user_id") @db.Uuid
  rawTranscript   String        @map("raw_transcript")
  cleanedText     String        @map("cleaned_text")
  summary         String?
  type            ThoughtType
  priority        Int           @default(3)
  categories      String[]      @default([])
  sentiment       Float?
  entities        Json          @default("{}")
  actionItems     String[]      @default([]) @map("action_items")
  deadline        DateTime?     @db.Timestamptz()
  completedAt     DateTime?     @map("completed_at") @db.Timestamptz()
  snoozedUntil    DateTime?     @map("snoozed_until") @db.Timestamptz()
  status          ThoughtStatus @default(active)
  // embedding handled via raw SQL (pgvector)
  embedding       Unsupported("vector(1536)")?
  audioUrl        String?       @map("audio_url")
  audioData       String?       @map("audio_data")
  audioMime       String?       @map("audio_mime") @db.VarChar(50)
  audioDuration   Float?        @map("audio_duration_seconds")
  calendarEventId String?       @map("calendar_event_id") @db.VarChar(255)
  todoistTaskId   String?       @map("todoist_task_id") @db.VarChar(255)
  notionPageId    String?       @map("notion_page_id") @db.VarChar(255)
  language        String        @default("cs") @db.VarChar(5)
  source          String        @default("voice") @db.VarChar(20)
  createdAt       DateTime      @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt       DateTime      @default(now()) @updatedAt @map("updated_at") @db.Timestamptz()

  user            User          @relation(fields: [userId], references: [id])
  notifications   Notification[]
  connectionsA    ThoughtConnection[] @relation("ThoughtA")
  connectionsB    ThoughtConnection[] @relation("ThoughtB")

  @@index([userId, status])
  @@index([userId, type])
  @@index([deadline])
  @@map("thoughts")
}

model ThoughtConnection {
  id             String   @id @default(uuid()) @db.Uuid
  thoughtAId     String   @map("thought_a_id") @db.Uuid
  thoughtBId     String   @map("thought_b_id") @db.Uuid
  similarity     Float
  connectionType String   @default("semantic") @map("connection_type") @db.VarChar(20)
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz()

  thoughtA       Thought  @relation("ThoughtA", fields: [thoughtAId], references: [id], onDelete: Cascade)
  thoughtB       Thought  @relation("ThoughtB", fields: [thoughtBId], references: [id], onDelete: Cascade)

  @@unique([thoughtAId, thoughtBId])
  @@map("thought_connections")
}

model Notification {
  id           String    @id @default(uuid()) @db.Uuid
  userId       String    @map("user_id") @db.Uuid
  thoughtId    String?   @map("thought_id") @db.Uuid
  type         String    @db.VarChar(20)
  title        String
  body         String?
  url          String?
  scheduledFor DateTime  @map("scheduled_for") @db.Timestamptz()
  sentAt       DateTime? @map("sent_at") @db.Timestamptz()
  readAt       DateTime? @map("read_at") @db.Timestamptz()
  dismissedAt  DateTime? @map("dismissed_at") @db.Timestamptz()
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz()

  user         User      @relation(fields: [userId], references: [id])
  thought      Thought?  @relation(fields: [thoughtId], references: [id])

  @@index([userId, scheduledFor])
  @@index([userId, readAt])
  @@map("notifications")
}

model PushSubscription {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  endpoint  String   @unique
  p256dh    String
  auth      String
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz()
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("push_subscriptions")
}

model Account {
  id                String  @id @default(uuid()) @db.Uuid
  userId            String  @map("user_id") @db.Uuid
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model VerificationToken {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  token     String   @unique @db.VarChar(255)
  type      String   @db.VarChar(20)
  expiresAt DateTime @map("expires_at") @db.Timestamptz()
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz()
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId, type])
  @@map("verification_tokens")
}
